package smg

import (
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"testing"
	"time"
)

const (
	baseURL     = "https://www.example.com"
	n           = 5
	letterBytes = "////abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
)

var (
	lenLetters = len(letterBytes)
)

func buildRoutes(n, l, s int) []string {
	rand.Seed(time.Now().UnixNano())

	routes := make([]string, n)
	for i := range routes {
		routes[i] = randString(rand.Intn(l) + s)
	}
	return routes
}

func randString(n int) string {
	b := make([]byte, n)
	for i := range b {
		b[i] = letterBytes[rand.Intn(lenLetters)]
	}
	return string(b)
}

// TestCompleteAction tests the whole sitemap-generator module with a semi-basic usage
func TestCompleteAction(t *testing.T) {
	routes := buildRoutes(10, 40, 10)
	randNum := rand.Intn(900) + 100
	path := fmt.Sprintf("/tmp/sitemap_output_%d", randNum)

	smi := NewSitemapIndex(true)
	smi.SetCompress(false)
	smi.SetHostname(baseURL)
	smi.SetSitemapIndexName("test_sitemap_index")
	smi.SetOutputPath(path)
	now := time.Now().UTC()

	// Testing a list of named sitemaps
	a := []string{"test_sitemap1", "test_sitemap2", "test_sitemap3", "test_sitemap4", "test_sitemap5"}
	for _, name := range a {
		sm := smi.NewSitemap()
		sm.SetName(name)
		sm.SetLastMod(&now)
		for _, route := range routes {
			err := sm.Add(&SitemapLoc{
				Loc:        route,
				LastMod:    &now,
				ChangeFreq: Always,
				Priority:   0.4,
			})
			if err != nil {
				t.Fatal("Unable to add SitemapLoc:", name, err)
			}
		}
	}

	// Testing another one with autogenerated name:
	sm := smi.NewSitemap()
	for _, route := range routes {
		err := sm.Add(&SitemapLoc{
			Loc:        route,
			LastMod:    &now,
			ChangeFreq: Daily,
			Priority:   0.8,
		})
		if err != nil {
			t.Fatal("Unable to add 6th SitemapLoc:", err)
		}
	}

	// Testing another one with 100001 items to be split to three files
	smLarge := smi.NewSitemap()
	smLarge.SetName("fake_name_which_will_be_changed")
	moreRoutes := buildRoutes(100001, 40, 10)
	for _, route := range moreRoutes {
		err := smLarge.Add(&SitemapLoc{
			Loc:        route,
			LastMod:    &now,
			ChangeFreq: Hourly,
			Priority:   1,
		})
		if err != nil {
			t.Fatal("Unable to add large SitemapLoc:", err)
		}
	}
	// Testing changing Name after building a large sitemap which is split into several files
	smLarge.SetName("large")
	assertURLsCount(t, smLarge)

	// Testing another one with 100001 items to be split to three files
	smBig := smi.NewSitemap()
	smBig.SetName("big")
	bigRoutes := buildRoutes(20000, 4000, 1000)
	for _, route := range bigRoutes {
		err := smBig.Add(&SitemapLoc{
			Loc:        route,
			LastMod:    &now,
			ChangeFreq: Hourly,
			Priority:   1,
		})
		if err != nil {
			t.Fatal("Unable to add large SitemapLoc:", err)
		}
	}

	err := smi.Save()
	if err != nil {
		t.Fatal("Unable to Save SitemapIndex:", err)
	}

	err = smi.PingSearchEngines()
	if err != nil {
		t.Fatal("Unable to Ping search engines:", err)
	}

	smi.SetCompress(true)
	err = smi.Save()
	if err != nil {
		t.Fatal("Unable to Save Compressed SitemapIndex:", err)
	}
	// -----------------------------------------------------------------

	// Checking 5 named output files
	for _, name := range a {
		// Compressed files;
		assertOutputFile(t, path, name+fileGzExt)
		// Plain files:
		assertOutputFile(t, path, name+fileExt)
	}
	// -----------------------------------------------------------------

	// Checking the 6th sitemap which was no-name:
	// Compressed files;
	assertOutputFile(t, path, "sitemap6"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "sitemap6"+fileExt)
	// -----------------------------------------------------------------

	// Checking the larger sitemap which was no-name, file no. 1:
	// Compressed files;
	assertOutputFile(t, path, "large"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "large"+fileExt)
	//  file no. 2:
	// Compressed files;
	assertOutputFile(t, path, "large1"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "large1"+fileExt)
	//  file no. 3:
	// Compressed files;
	assertOutputFile(t, path, "large2"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "large2"+fileExt)
	// -----------------------------------------------------------------

	// Checking the big sitemap which was bigger than 50MG and must be split into 2 files:
	// no. 1:
	// Compressed files;
	assertOutputFile(t, path, "big"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "big"+fileExt)
	// no. 2:
	// Compressed files;
	assertOutputFile(t, path, "big1"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "big1"+fileExt)
	// -----------------------------------------------------------------

	// Checking the sitemap_index file, compressed file:
	// Compressed files;
	assertOutputFile(t, path, "test_sitemap_index"+fileGzExt)
	// Plain files:
	assertOutputFile(t, path, "test_sitemap_index"+fileExt)
	// -----------------------------------------------------------------

	// Removing the generated path and files
	err = os.RemoveAll(path)
	if err != nil {
		t.Fatal("Unable to remove tmp path after testing:", err)
	}
	// -----------------------------------------------------------------
}

func assertOutputFile(t *testing.T, path, name string) {
	f, err := os.Stat(filepath.Join(path, name))
	if os.IsNotExist(err) || f.IsDir() {
		t.Fatal("File does not exist or is directory:", name, err)
	}
	if f.Size() == 0 {
		t.Fatal("Zero size:", name)
	} else if f.Size() > int64(maxFileSize) {
		t.Fatal("Size is more than limits:", name, f.Size())
	}
}

func assertURLsCount(t *testing.T, sm *Sitemap) {
	if sm.GetURLsCount() > maxURLsCount {
		t.Fatal("URLsCount is more than limits:", sm.Name, sm.GetURLsCount())
	}
}
